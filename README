C++ PL Compiler Project
========================

PL Compilter, Stage-3 (Scope and Type Checking Parser)
Authors: Chad Klassen, Jordan Peoples and Adam Shepley
Made for CPSC 4600

Revision: Third Hand-in, SCOPETYPE Revision

========================

Notes and Issues:
=====

It is important to note that PL, as we understand it, is composed of two
primary "segments" in a source file; a definition part and a statement part.
If one attempts to use a Statement part component before a definition part component,
or the contrapositive of that, i.e. one interweaves components of these outside of
the usage of Proc(edures), then this (correctly, according to the grammar)
generates a parsing error.

Additionally, we use a C++ compiler macro, "__func__", which creates a string
from the function name. If your compiler does not work with this macro,
please use a newer compiler such as MinGW or G++ or MSVC 2011 or Intel11.

Finally, some error types result in an inaccurate number of calls to SyntaxError
as the error reporting cascades sometimes. However, inaccurate errors should never
occur and the error count is accurate for the most part.
Thus, when a leading error is corrected, the subsequent resultant errors are also
automatically/implicitly corrected for.

New Notes:
====

Our documentation was appended to the altered Parser documentation file outline below.



Files Included:
=====

Source Files:
-admin.cpp
-admin.h

-first.cpp
-first.h
-parser.cpp
-parser.h
-set.cpp
-set.h

-main.cpp
-scanner.cpp
-scanner.h
-symboltable.cpp
-symboltable.h
-token.cpp
-token.h

-blocktable.h
-blocktable.cpp

Current Test Files:
Our test files are given the extension ".cpl".

-errorTokenTest.cpl
-blankSpaceTest.cpl
-linearSearch.cpl	- the primary search function test. Should be valid
-miscTest.cpl
-randomTest.cpl

Parser-Oriented Test Files:

-simple.cpl - Error program, with various ignored terminals to check if the parser breaks
	      on them.
-simple2.cpl - tests the "interweaving" of statement and definition parts, 
	       should result in errors but parse completely.
-simple3.cpl - tests a PL program with an empty proc block. Should pass.
-recursive.cpl - tests the chaining of functions together and base scope resolution. 
		Should pass successfully.
-empty.cpl - Tests an empty file. Should parse successfully 
	      (no errors found; nothing found, even.)
-lin.cpl - Tests the error reporting capability of the parser and its error 
	  recovery capability.
-constantRedeclarationTest.cpl - A fail test, tries to redeclare a constant.
-declindef.cpl - tests a declaration outside of the definition part, also with a wrong type name
-longdec.cpl	-Tests a very long list of declarations.
-redecl.cpl	-Tests the redeclaration of one type in longdec.cpl
-wrong comparison.cpl	-tests a comparison with mismatching types and without proper guards.


Official Documentation:
README (ascii file)
"Technical Documentation ASCII.txt" - ASCII Documentation for the Scanner
"Technical Documentation - Parser (ASCII).txt" - ASCII Documentation for the 
			  Parser and Scope/Type Checking.

Other Files:
DoxyFile (doxygen documentation generator file)
MakeFile (makefile for the actual project)

==========================

How To Compile
-------------

Run "make" in the root directory. This should compile the actual project;
from there, run the "main" binary to execute the project.

Alternatively, run "make -f MakeFile" to compile the scanner/compiler.

To create fresh doxygen documentation, run "doxygen DoxyFile".

No syntactic or compiling or run time errors were found as of writing.

=========================

How To Run
-----------

After compiling, you will have a "main" program (or main.exe on Windows).
Execute the Binary (using "./main") with one argument.

The argument used is the name of the test PL file/directory-to-file you would like to use.

i.e. for our base test case, the command would be:

./main errorTokenTest.cpl

and our program would interpret the argument as the test file argument.
If multiple arguments are present, only the first one will be used.

This name *can* contain a directory path, but only if represented by forward slashes.
As such, we will not support a Test directory as of yet, and test files will be located
in the root directory.

============================

Approximate Hours Spent on the Scanner:

Jordan Peoples - ~20 to ~25 hours
Adam Shepley - ~15 to ~23 hours
Chad Klassen - ~22 to ~27 hours

Approximate Hours Spent on the Parser (Stage 2 of Project):

Jordan Peoples - 25 to 38 Hours
Chad Klassen - 25 to 38 Hours
Adam Shepley - 15 to 22 Hours

Approximate Hours Spent on the Scope and Type Checking (Stage 3 of Project):

Jordan Peoples - 30 to 42 Hours
Chad Klassen - 33 to 45 Hours
Adam Shepley - 18 to 24 Hours


Note that these do not account for certain individual endeavours that were not known to the group.
These are also rough estimates of hours spent.

===========================

The Documentation is divided up into four components:

1) A technical documentation file, called "Technical Documentation ASCII.txt", which has a high level run-through and 
explanation of our scanner and its various components.
This file may be updated to reflect changes made to accomodate the Parser as well.
Located in /documentation/

2) A secondary documentation file, called "Technical Documentation - Parser (ASCII).txt", which documents the new additions 
to the compiler and gives a high-level explanation and run-through of our Parser code and components.

3) A Doxygen-generated HTML and LaTeX documentation of the actual code and functions, at a granular level.
Located in /documentation/html/index.html and /documentation/latex/

4) Heavily commented code in the Class specification and Implimentation files. In and of itself, these comments are designed to explain
the nuances of the compiler, both the Scanner and the Parser.